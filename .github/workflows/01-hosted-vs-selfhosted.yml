name: 04 - Ephemeral / JIT (autoscale prep)

on:
  workflow_dispatch:

permissions:
  contents: read
  actions: write   # required to generate JIT config

jobs:
  generate-jit-config:
    runs-on: ubuntu-latest
    steps:
      - uses: cli/cli-action@v2

      - name: Generate JIT runner config (ephemeral)
        id: jit
        run: |
          # labels can include "ephemeral" and whatever routing labels you want
          gh api \
            -X POST \
            repos/${{ github.repository }}/actions/runners/generate-jitconfig \
            -f name="jit-ephemeral-$(date +%s)" \
            -f work_folder="_work" \
            -f runner_group_id="" \
            -f labels="self-hosted,linux,ephemeral" \
            --jq '.encoded_jit_config' > jitconfig.b64

          echo "encoded=$(cat jitconfig.b64)" >> $GITHUB_OUTPUT

      - name: Upload JIT config artifact
        uses: actions/upload-artifact@v4
        with:
          name: jitconfig
          path: jitconfig.b64

      - name: Show next step (what to run on your auto-scaling host)
        run: |
          cat <<'JITREADME'
          To start a JIT ephemeral runner on your host/VM/container:

            # Get the latest runner binary for your OS/arch, then:
            ./run.sh --jitconfig $(cat jitconfig.b64)

          The runner will pick up exactly ONE job and then remove itself.
          This is how autoscaling solutions (e.g., GitHub's ARC on Kubernetes or your own) keep runners clean.
          JITREADME
